定义：为其它对象提供一种代理以控制对这个对象的访问。
角色：
Subject抽象主题角色：可以是抽象类也可以是接口，业务类型定义
RealSubject具体主题角色：被委托角色被代理角色，是具体业务逻辑的具体执行者
Proxy代理主题角色：委托类、代理类，负责对真是角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，
并且在真实主题角色处理完毕前后做预处理和善后处理工作
优点：
1、职责清晰
2、高拓展性
3、智能化
场景：
调用者不用通过了解中间具体实现，而通过第三方调用完成，如Spring AOP
拓展：
1、普通代理
普通代理需要知道代理的存在，才能访问；
客户端只能访问代理角色，而不能访问真实角色；调用者只知道代理是谁而不知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响；
适合对拓展性要求较高的场合，只需要实现接口锁对应的接口即可
在实际项目中，一般都是通过约定来禁止new一个真实的对象，是比较好的方案，优于技术约束
2、强制代理
调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的；必须通过真实角色找到代理角色，否则无法访问。
通过代理对象和真实主题角色类都不能访问
不需要产生代理，代理的管理由真实角色自己完成
3、代理个性化
在目标对象方法的基础上作增强；代理类不仅仅可以由自己的运算方法，通常情况下代理的职责并不一定单一，它可以组合其它的真实角色，也可以实现自己的职责，比如计算费用
4、虚拟代理
在代理模式的通用代码上作修改即可，在需要的时候才初始化主题对象，可以避免被代理对象较多而引起的初始化缓慢的问题，缺点是需要在每个方法中判断主题对象是否被创建
5、动态代理
在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象；自己写静态类的方式就是静态代理
APO的核心就是采用了动态代理机制
动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称它实现了该接口下的所有方法
动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系
所有通过动态代理实习的方法全部通过invoke方法调用
首要条件：被代理类必须实现一个接口
APO相关名次：切面、切入点、通知、织入
