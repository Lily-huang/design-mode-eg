定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。
组成：
抽象产品类负责定义产品的共性，实现对事物最抽象的定义
抽象创建类也就是抽象工厂，具体如何创建产品类是由具体的实现工厂完成
优点：
1、良好的封装性，代码结构清晰；一个对象的创建是有条件约束的，如一个调用者需要一个具体的产品对象，只需要知道类名就可以了
2、拓展性优秀；在增加产品类的情况下，只需要适当修改具体的工厂类或者拓展一个工厂类，就可以适应变化
3、屏蔽了产品类；产品类实现的变化并不需要知道，祝需要关心产品的接口即可，接口不变则上层模块不需要变化（JDBC连接数据库如果系切换数据库，只需要修改驱动即可适配）
4、工厂方法模式是典型的解耦框架；高层模块只需要知道产品的抽象类，其它的实现类都不用关心，符合：
迪米特法则：不需要的就不去交流
依赖倒置原则：只依赖产生类的抽象
里氏替换原则：使用产品子类替换产品父类
使用场景：
1、工厂方法模式是new一个对象的替代品
2、需要灵活的、可扩展的框架时；具有共性及使用流程的多个产品，可以抽象成为产品类
3、异构项目中；工厂类管理非同一语言服务
4、可以使用在测试驱动开发的框架下
拓展：
1、简单工厂模式（静态工厂模式）
一个模块仅需要一个工厂类，没有必要生产出来，使用静态的方法就可以
只有一个非抽象工厂类，其中含有根据产品子类类型产生对象的静态方法
2、升级为多个工厂类
初始化一个对象很耗费经理，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰
每一种产品子类对应的实现工厂都不同，其中不同产品的初始化等实现方法可以分开，便于管理
此时抽象工厂实现方法中不需要再传入参数，因为工厂实现类已经决定了具体的产品类
好处：每一个产品类都对应了一个创建类，创建类的职责清晰，结构简单，但是在拓展和维护上增加了成本，因为要拓展一个产品类，还需要建立一个相应的工厂类
工厂类和产品类的数量相同，维护时需要考虑两个对象之间的关系，可以增加一个协调类，避免调用者与各个子工厂交流，封装子工厂类面对高层模块提供统一的访问接口
3、替代单例模式
可以通过工厂方法模式创建单例对象，单例的构造方法必须私有，避免其它创建方式，且团队开发必须遵循统一的产生实例方法
在项目中可以产生一个单例构造器，所有需要产生单例的类都遵循一定的规则（构造方法是private），然后通过拓展该框架，只需要输入一个类型就可以获得唯一的一个实例
4、延迟初始化
一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用
工厂类中产生产品的方法为同步方法，当调用其进行产品初始化时，如果map中有所需产品类，则从map中get返回，否则产生类存放在在map中并返回
拓展：
限制某一个产品类的最大实例化数量（判断map中已有数量），如JDBC连接数据库的最大连接数量，该数量就是内存中最大实例化的数量
对象初始化比较复杂的情况，如硬件访问，涉及多方面的交互，可通过延迟加载降低对象的产生和销毁带来的复杂性
